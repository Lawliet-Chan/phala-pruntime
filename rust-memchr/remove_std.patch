diff --git a/src/lib.rs b/src/lib.rs
index b828475..85b47e6 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -20,7 +20,7 @@ provides its own implementation of `memrchr` as well, on top of `memchr2`,
 instead of one. Similarly for `memchr3`.
 */
 
-#![cfg_attr(not(feature = "use_std"), no_std)]
+#![no_std]
 
 #![deny(missing_docs)]
 #![doc(html_root_url = "https://docs.rs/memchr/2.0.0")]
@@ -30,8 +30,8 @@ instead of one. Similarly for `memchr3`.
 #[cfg(not(any(target_pointer_width = "32", target_pointer_width = "64")))]
 compile_error!("memchr currently not supported on non-32 or non-64 bit");
 
-#[cfg(feature = "use_std")]
-extern crate core;
+// #[cfg(feature = "use_std")]
+// extern crate core;
 
 #[cfg(test)]
 #[macro_use]
diff --git a/src/x86/mod.rs b/src/x86/mod.rs
index b8bdd7b..284b6ae 100644
--- a/src/x86/mod.rs
+++ b/src/x86/mod.rs
@@ -2,8 +2,6 @@ use fallback;
 
 // We only use AVX when we can detect at runtime whether it's available, which
 // requires std.
-#[cfg(feature = "use_std")]
-mod avx;
 mod sse2;
 
 // This macro employs a gcc-like "ifunc" trick where by upon first calling
@@ -27,43 +25,7 @@ mod sse2;
 // probably can't be inlined anyway---unless you've compiled your entire
 // program with AVX2 enabled. However, even then, the various memchr
 // implementations aren't exactly small, so inlining might not help anyway!
-#[cfg(feature = "use_std")]
-macro_rules! ifunc {
-    ($fnty:ty, $name:ident, $haystack:ident, $($needle:ident),+) => {{
-        use std::mem;
-        use std::sync::atomic::{AtomicPtr, Ordering};
-
-        type FnRaw = *mut ();
-
-        static FN: AtomicPtr<()> = AtomicPtr::new(detect as FnRaw);
-
-        fn detect($($needle: u8),+, haystack: &[u8]) -> Option<usize> {
-            let fun =
-                if cfg!(memchr_runtime_avx) && is_x86_feature_detected!("avx2") {
-                    avx::$name as FnRaw
-                } else if cfg!(memchr_runtime_sse2) {
-                    sse2::$name as FnRaw
-                } else {
-                    fallback::$name as FnRaw
-                };
-            FN.store(fun as FnRaw, Ordering::Relaxed);
-            unsafe {
-                mem::transmute::<FnRaw, $fnty>(fun)($($needle),+, haystack)
-            }
-        }
-
-        unsafe {
-            let fun = FN.load(Ordering::Relaxed);
-            mem::transmute::<FnRaw, $fnty>(fun)($($needle),+, $haystack)
-        }
-    }}
-}
 
-// When std isn't available to provide runtime CPU feature detection, or if
-// runtime CPU feature detection has been explicitly disabled, then just call
-// our optimized SSE2 routine directly. SSE2 is avalbale on all x86_64 targets,
-// so no CPU feature detection is necessary.
-#[cfg(not(feature = "use_std"))]
 macro_rules! ifunc {
     ($fnty:ty, $name:ident, $haystack:ident, $($needle:ident),+) => {{
         if cfg!(memchr_runtime_sse2) {
